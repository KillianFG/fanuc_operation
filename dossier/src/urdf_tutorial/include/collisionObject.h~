00001 /* Auto-generated by genmsg_cpp for file /tmp/buildd/ros-diamondback-motion-planning-common-0.3.6/debian/ros-diamondback-motion-planning-common/opt/ros/diamondback/stacks/motion_planning_common/mapping_msgs/msg/CollisionObject.msg */
00002 #ifndef MAPPING_MSGS_MESSAGE_COLLISIONOBJECT_H
00003 #define MAPPING_MSGS_MESSAGE_COLLISIONOBJECT_H
00004 #include <string>
00005 #include <vector>
00006 #include <ostream>
00007 #include "ros/serialization.h"
00008 #include "ros/builtin_message_traits.h"
00009 #include "ros/message_operations.h"
00010 #include "ros/message.h"
00011 #include "ros/time.h"
00012 
00013 #include "std_msgs/Header.h"
00014 #include "mapping_msgs/CollisionObjectOperation.h"
00015 #include "geometric_shapes_msgs/Shape.h"
00016 #include "geometry_msgs/Pose.h"
00017 
00018 namespace mapping_msgs
00019 {
00020 template <class ContainerAllocator>
00021 struct CollisionObject_ : public ros::Message
00022 {
00023   typedef CollisionObject_<ContainerAllocator> Type;
00024 
00025   CollisionObject_()
00026   : header()
00027   , id()
00028   , operation()
00029   , shapes()
00030   , poses()
00031   {
00032   }
00033 
00034   CollisionObject_(const ContainerAllocator& _alloc)
00035   : header(_alloc)
00036   , id(_alloc)
00037   , operation(_alloc)
00038   , shapes(_alloc)
00039   , poses(_alloc)
00040   {
00041   }
00042 
00043   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
00044    ::std_msgs::Header_<ContainerAllocator>  header;
00045 
00046   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _id_type;
00047   std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  id;
00048 
00049   typedef  ::mapping_msgs::CollisionObjectOperation_<ContainerAllocator>  _operation_type;
00050    ::mapping_msgs::CollisionObjectOperation_<ContainerAllocator>  operation;
00051 
00052   typedef std::vector< ::geometric_shapes_msgs::Shape_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometric_shapes_msgs::Shape_<ContainerAllocator> >::other >  _shapes_type;
00053   std::vector< ::geometric_shapes_msgs::Shape_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometric_shapes_msgs::Shape_<ContainerAllocator> >::other >  shapes;
00054 
00055   typedef std::vector< ::geometry_msgs::Pose_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Pose_<ContainerAllocator> >::other >  _poses_type;
00056   std::vector< ::geometry_msgs::Pose_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Pose_<ContainerAllocator> >::other >  poses;
00057 
00058 
00059   ROS_DEPRECATED uint32_t get_shapes_size() const { return (uint32_t)shapes.size(); }
00060   ROS_DEPRECATED void set_shapes_size(uint32_t size) { shapes.resize((size_t)size); }
00061   ROS_DEPRECATED void get_shapes_vec(std::vector< ::geometric_shapes_msgs::Shape_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometric_shapes_msgs::Shape_<ContainerAllocator> >::other > & vec) const { vec = this->shapes; }
00062   ROS_DEPRECATED void set_shapes_vec(const std::vector< ::geometric_shapes_msgs::Shape_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometric_shapes_msgs::Shape_<ContainerAllocator> >::other > & vec) { this->shapes = vec; }
00063   ROS_DEPRECATED uint32_t get_poses_size() const { return (uint32_t)poses.size(); }
00064   ROS_DEPRECATED void set_poses_size(uint32_t size) { poses.resize((size_t)size); }
00065   ROS_DEPRECATED void get_poses_vec(std::vector< ::geometry_msgs::Pose_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Pose_<ContainerAllocator> >::other > & vec) const { vec = this->poses; }
00066   ROS_DEPRECATED void set_poses_vec(const std::vector< ::geometry_msgs::Pose_<ContainerAllocator> , typename ContainerAllocator::template rebind< ::geometry_msgs::Pose_<ContainerAllocator> >::other > & vec) { this->poses = vec; }
00067 private:
00068   static const char* __s_getDataType_() { return "mapping_msgs/CollisionObject"; }
00069 public:
00070   ROS_DEPRECATED static const std::string __s_getDataType() { return __s_getDataType_(); }
00071 
00072   ROS_DEPRECATED const std::string __getDataType() const { return __s_getDataType_(); }
00073 
00074 private:
00075   static const char* __s_getMD5Sum_() { return "c25d22faff81b340d88e28e270ae03f5"; }
00076 public:
00077   ROS_DEPRECATED static const std::string __s_getMD5Sum() { return __s_getMD5Sum_(); }
00078 
00079   ROS_DEPRECATED const std::string __getMD5Sum() const { return __s_getMD5Sum_(); }
00080 
00081 private:
00082   static const char* __s_getMessageDefinition_() { return "# a header, used for interpreting the poses\n\
00083 Header header\n\
00084 \n\
00085 # the id of the object\n\
00086 string id\n\
00087 \n\
00088 #This contains what is to be done with the object\n\
00089 CollisionObjectOperation operation\n\
00090 \n\
00091 #the shapes associated with the object\n\
00092 geometric_shapes_msgs/Shape[] shapes\n\
00093 \n\
00094 #the poses associated with the shapes - will be transformed using the header\n\
00095 geometry_msgs/Pose[] poses\n\
00096 \n\
00097 ================================================================================\n\
00098 MSG: std_msgs/Header\n\
00099 # Standard metadata for higher-level stamped data types.\n\
00100 # This is generally used to communicate timestamped data \n\
00101 # in a particular coordinate frame.\n\
00102 # \n\
00103 # sequence ID: consecutively increasing ID \n\
00104 uint32 seq\n\
00105 #Two-integer timestamp that is expressed as:\n\
00106 # * stamp.secs: seconds (stamp_secs) since epoch\n\
00107 # * stamp.nsecs: nanoseconds since stamp_secs\n\
00108 # time-handling sugar is provided by the client library\n\
00109 time stamp\n\
00110 #Frame this data is associated with\n\
00111 # 0: no frame\n\
00112 # 1: global frame\n\
00113 string frame_id\n\
00114 \n\
00115 ================================================================================\n\
00116 MSG: mapping_msgs/CollisionObjectOperation\n\
00117 #Puts the object into the environment\n\
00118 #or updates the object if already added\n\
00119 byte ADD=0\n\
00120 \n\
00121 #Removes the object from the environment entirely\n\
00122 byte REMOVE=1\n\
00123 \n\
00124 #Only valid within the context of a CollisionAttachedObject message\n\
00125 #Will be ignored if sent with an CollisionObject message\n\
00126 #Takes an attached object, detaches from the attached link\n\
00127 #But adds back in as regular object\n\
00128 byte DETACH_AND_ADD_AS_OBJECT=2\n\
00129 \n\
00130 #Only valid within the context of a CollisionAttachedObject message\n\
00131 #Will be ignored if sent with an CollisionObject message\n\
00132 #Takes current object in the environment and removes it as\n\
00133 #a regular object\n\
00134 byte ATTACH_AND_REMOVE_AS_OBJECT=3\n\
00135 \n\
00136 # Byte code for operation\n\
00137 byte operation\n\
00138 \n\
00139 ================================================================================\n\
00140 MSG: geometric_shapes_msgs/Shape\n\
00141 byte SPHERE=0\n\
00142 byte BOX=1\n\
00143 byte CYLINDER=2\n\
00144 byte MESH=3\n\
00145 \n\
00146 byte type\n\
00147 \n\
00148 \n\
00149 #### define sphere, box, cylinder ####\n\
00150 # the origin of each shape is considered at the shape's center\n\
00151 \n\
00152 # for sphere\n\
00153 # radius := dimensions[0]\n\
00154 \n\
00155 # for cylinder\n\
00156 # radius := dimensions[0]\n\
00157 # length := dimensions[1]\n\
00158 # the length is along the Z axis\n\
00159 \n\
00160 # for box\n\
00161 # size_x := dimensions[0]\n\
00162 # size_y := dimensions[1]\n\
00163 # size_z := dimensions[2]\n\
00164 float64[] dimensions\n\
00165 \n\
00166 \n\
00167 #### define mesh ####\n\
00168 \n\
00169 # list of triangles; triangle k is defined by tre vertices located\n\
00170 # at indices triangles[3k], triangles[3k+1], triangles[3k+2]\n\
00171 int32[] triangles\n\
00172 geometry_msgs/Point[] vertices\n\
00173 \n\
00174 ================================================================================\n\
00175 MSG: geometry_msgs/Point\n\
00176 # This contains the position of a point in free space\n\
00177 float64 x\n\
00178 float64 y\n\
00179 float64 z\n\
00180 \n\
00181 ================================================================================\n\
00182 MSG: geometry_msgs/Pose\n\
00183 # A representation of pose in free space, composed of postion and orientation. \n\
00184 Point position\n\
00185 Quaternion orientation\n\
00186 \n\
00187 ================================================================================\n\
00188 MSG: geometry_msgs/Quaternion\n\
00189 # This represents an orientation in free space in quaternion form.\n\
00190 \n\
00191 float64 x\n\
00192 float64 y\n\
00193 float64 z\n\
00194 float64 w\n\
00195 \n\
00196 "; }
00197 public:
00198   ROS_DEPRECATED static const std::string __s_getMessageDefinition() { return __s_getMessageDefinition_(); }
00199 
00200   ROS_DEPRECATED const std::string __getMessageDefinition() const { return __s_getMessageDefinition_(); }
00201 
00202   ROS_DEPRECATED virtual uint8_t *serialize(uint8_t *write_ptr, uint32_t seq) const
00203   {
00204     ros::serialization::OStream stream(write_ptr, 1000000000);
00205     ros::serialization::serialize(stream, header);
00206     ros::serialization::serialize(stream, id);
00207     ros::serialization::serialize(stream, operation);
00208     ros::serialization::serialize(stream, shapes);
00209     ros::serialization::serialize(stream, poses);
00210     return stream.getData();
00211   }
00212 
00213   ROS_DEPRECATED virtual uint8_t *deserialize(uint8_t *read_ptr)
00214   {
00215     ros::serialization::IStream stream(read_ptr, 1000000000);
00216     ros::serialization::deserialize(stream, header);
00217     ros::serialization::deserialize(stream, id);
00218     ros::serialization::deserialize(stream, operation);
00219     ros::serialization::deserialize(stream, shapes);
00220     ros::serialization::deserialize(stream, poses);
00221     return stream.getData();
00222   }
00223 
00224   ROS_DEPRECATED virtual uint32_t serializationLength() const
00225   {
00226     uint32_t size = 0;
00227     size += ros::serialization::serializationLength(header);
00228     size += ros::serialization::serializationLength(id);
00229     size += ros::serialization::serializationLength(operation);
00230     size += ros::serialization::serializationLength(shapes);
00231     size += ros::serialization::serializationLength(poses);
00232     return size;
00233   }
00234 
00235   typedef boost::shared_ptr< ::mapping_msgs::CollisionObject_<ContainerAllocator> > Ptr;
00236   typedef boost::shared_ptr< ::mapping_msgs::CollisionObject_<ContainerAllocator>  const> ConstPtr;
00237 }; // struct CollisionObject
00238 typedef  ::mapping_msgs::CollisionObject_<std::allocator<void> > CollisionObject;
00239 
00240 typedef boost::shared_ptr< ::mapping_msgs::CollisionObject> CollisionObjectPtr;
00241 typedef boost::shared_ptr< ::mapping_msgs::CollisionObject const> CollisionObjectConstPtr;
00242 
00243 
00244 template<typename ContainerAllocator>
00245 std::ostream& operator<<(std::ostream& s, const  ::mapping_msgs::CollisionObject_<ContainerAllocator> & v)
00246 {
00247   ros::message_operations::Printer< ::mapping_msgs::CollisionObject_<ContainerAllocator> >::stream(s, "", v);
00248   return s;}
00249 
00250 } // namespace mapping_msgs
00251 
00252 namespace ros
00253 {
00254 namespace message_traits
00255 {
00256 template<class ContainerAllocator>
00257 struct MD5Sum< ::mapping_msgs::CollisionObject_<ContainerAllocator> > {
00258   static const char* value() 
00259   {
00260     return "c25d22faff81b340d88e28e270ae03f5";
00261   }
00262 
00263   static const char* value(const  ::mapping_msgs::CollisionObject_<ContainerAllocator> &) { return value(); } 
00264   static const uint64_t static_value1 = 0xc25d22faff81b340ULL;
00265   static const uint64_t static_value2 = 0xd88e28e270ae03f5ULL;
00266 };
00267 
00268 template<class ContainerAllocator>
00269 struct DataType< ::mapping_msgs::CollisionObject_<ContainerAllocator> > {
00270   static const char* value() 
00271   {
00272     return "mapping_msgs/CollisionObject";
00273   }
00274 
00275   static const char* value(const  ::mapping_msgs::CollisionObject_<ContainerAllocator> &) { return value(); } 
00276 };
00277 
00278 template<class ContainerAllocator>
00279 struct Definition< ::mapping_msgs::CollisionObject_<ContainerAllocator> > {
00280   static const char* value() 
00281   {
00282     return "# a header, used for interpreting the poses\n\
00283 Header header\n\
00284 \n\
00285 # the id of the object\n\
00286 string id\n\
00287 \n\
00288 #This contains what is to be done with the object\n\
00289 CollisionObjectOperation operation\n\
00290 \n\
00291 #the shapes associated with the object\n\
00292 geometric_shapes_msgs/Shape[] shapes\n\
00293 \n\
00294 #the poses associated with the shapes - will be transformed using the header\n\
00295 geometry_msgs/Pose[] poses\n\
00296 \n\
00297 ================================================================================\n\
00298 MSG: std_msgs/Header\n\
00299 # Standard metadata for higher-level stamped data types.\n\
00300 # This is generally used to communicate timestamped data \n\
00301 # in a particular coordinate frame.\n\
00302 # \n\
00303 # sequence ID: consecutively increasing ID \n\
00304 uint32 seq\n\
00305 #Two-integer timestamp that is expressed as:\n\
00306 # * stamp.secs: seconds (stamp_secs) since epoch\n\
00307 # * stamp.nsecs: nanoseconds since stamp_secs\n\
00308 # time-handling sugar is provided by the client library\n\
00309 time stamp\n\
00310 #Frame this data is associated with\n\
00311 # 0: no frame\n\
00312 # 1: global frame\n\
00313 string frame_id\n\
00314 \n\
00315 ================================================================================\n\
00316 MSG: mapping_msgs/CollisionObjectOperation\n\
00317 #Puts the object into the environment\n\
00318 #or updates the object if already added\n\
00319 byte ADD=0\n\
00320 \n\
00321 #Removes the object from the environment entirely\n\
00322 byte REMOVE=1\n\
00323 \n\
00324 #Only valid within the context of a CollisionAttachedObject message\n\
00325 #Will be ignored if sent with an CollisionObject message\n\
00326 #Takes an attached object, detaches from the attached link\n\
00327 #But adds back in as regular object\n\
00328 byte DETACH_AND_ADD_AS_OBJECT=2\n\
00329 \n\
00330 #Only valid within the context of a CollisionAttachedObject message\n\
00331 #Will be ignored if sent with an CollisionObject message\n\
00332 #Takes current object in the environment and removes it as\n\
00333 #a regular object\n\
00334 byte ATTACH_AND_REMOVE_AS_OBJECT=3\n\
00335 \n\
00336 # Byte code for operation\n\
00337 byte operation\n\
00338 \n\
00339 ================================================================================\n\
00340 MSG: geometric_shapes_msgs/Shape\n\
00341 byte SPHERE=0\n\
00342 byte BOX=1\n\
00343 byte CYLINDER=2\n\
00344 byte MESH=3\n\
00345 \n\
00346 byte type\n\
00347 \n\
00348 \n\
00349 #### define sphere, box, cylinder ####\n\
00350 # the origin of each shape is considered at the shape's center\n\
00351 \n\
00352 # for sphere\n\
00353 # radius := dimensions[0]\n\
00354 \n\
00355 # for cylinder\n\
00356 # radius := dimensions[0]\n\
00357 # length := dimensions[1]\n\
00358 # the length is along the Z axis\n\
00359 \n\
00360 # for box\n\
00361 # size_x := dimensions[0]\n\
00362 # size_y := dimensions[1]\n\
00363 # size_z := dimensions[2]\n\
00364 float64[] dimensions\n\
00365 \n\
00366 \n\
00367 #### define mesh ####\n\
00368 \n\
00369 # list of triangles; triangle k is defined by tre vertices located\n\
00370 # at indices triangles[3k], triangles[3k+1], triangles[3k+2]\n\
00371 int32[] triangles\n\
00372 geometry_msgs/Point[] vertices\n\
00373 \n\
00374 ================================================================================\n\
00375 MSG: geometry_msgs/Point\n\
00376 # This contains the position of a point in free space\n\
00377 float64 x\n\
00378 float64 y\n\
00379 float64 z\n\
00380 \n\
00381 ================================================================================\n\
00382 MSG: geometry_msgs/Pose\n\
00383 # A representation of pose in free space, composed of postion and orientation. \n\
00384 Point position\n\
00385 Quaternion orientation\n\
00386 \n\
00387 ================================================================================\n\
00388 MSG: geometry_msgs/Quaternion\n\
00389 # This represents an orientation in free space in quaternion form.\n\
00390 \n\
00391 float64 x\n\
00392 float64 y\n\
00393 float64 z\n\
00394 float64 w\n\
00395 \n\
00396 ";
00397   }
00398 
00399   static const char* value(const  ::mapping_msgs::CollisionObject_<ContainerAllocator> &) { return value(); } 
00400 };
00401 
00402 template<class ContainerAllocator> struct HasHeader< ::mapping_msgs::CollisionObject_<ContainerAllocator> > : public TrueType {};
00403 template<class ContainerAllocator> struct HasHeader< const ::mapping_msgs::CollisionObject_<ContainerAllocator> > : public TrueType {};
00404 } // namespace message_traits
00405 } // namespace ros
00406 
00407 namespace ros
00408 {
00409 namespace serialization
00410 {
00411 
00412 template<class ContainerAllocator> struct Serializer< ::mapping_msgs::CollisionObject_<ContainerAllocator> >
00413 {
00414   template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
00415   {
00416     stream.next(m.header);
00417     stream.next(m.id);
00418     stream.next(m.operation);
00419     stream.next(m.shapes);
00420     stream.next(m.poses);
00421   }
00422 
00423   ROS_DECLARE_ALLINONE_SERIALIZER;
00424 }; // struct CollisionObject_
00425 } // namespace serialization
00426 } // namespace ros
00427 
00428 namespace ros
00429 {
00430 namespace message_operations
00431 {
00432 
00433 template<class ContainerAllocator>
00434 struct Printer< ::mapping_msgs::CollisionObject_<ContainerAllocator> >
00435 {
00436   template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::mapping_msgs::CollisionObject_<ContainerAllocator> & v) 
00437   {
00438     s << indent << "header: ";
00439 s << std::endl;
00440     Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
00441     s << indent << "id: ";
00442     Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.id);
00443     s << indent << "operation: ";
00444 s << std::endl;
00445     Printer< ::mapping_msgs::CollisionObjectOperation_<ContainerAllocator> >::stream(s, indent + "  ", v.operation);
00446     s << indent << "shapes[]" << std::endl;
00447     for (size_t i = 0; i < v.shapes.size(); ++i)
00448     {
00449       s << indent << "  shapes[" << i << "]: ";
00450       s << std::endl;
00451       s << indent;
00452       Printer< ::geometric_shapes_msgs::Shape_<ContainerAllocator> >::stream(s, indent + "    ", v.shapes[i]);
00453     }
00454     s << indent << "poses[]" << std::endl;
00455     for (size_t i = 0; i < v.poses.size(); ++i)
00456     {
00457       s << indent << "  poses[" << i << "]: ";
00458       s << std::endl;
00459       s << indent;
00460       Printer< ::geometry_msgs::Pose_<ContainerAllocator> >::stream(s, indent + "    ", v.poses[i]);
00461     }
00462   }
00463 };
00464 
00465 
00466 } // namespace message_operations
00467 } // namespace ros
00468 
00469 #endif // MAPPING_MSGS_MESSAGE_COLLISIONOBJECT_H
00470 


mapping_msgs
Author(s): Ioan Sucan
autogenerated on Fri Jan 11 09:15:30 2013 
